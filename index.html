<div style="position: absolute; z-index: 99999">
      <input autocomplete="off" type="checkbox" id="aadsstickymek0d0tj" hidden />
      <div style="padding-top: auto; padding-bottom: 0;">
        <div style="width:100%;height:auto;position:fixed;text-align:center;font-size:0;top:0;left:0;right:0;margin:auto">
          <label for="aadsstickymek0d0tj" style="top: 50%;transform: translateY(-50%);right:24px;; position: absolute;border-radius: 4px; background: rgba(248, 248, 249, 0.70); padding: 4px;z-index: 99999;cursor:pointer">
            <svg fill="#000000" height="16px" width="16px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 490 490">
              <polygon points="456.851,0 245,212.564 33.149,0 0.708,32.337 212.669,245.004 0.708,457.678 33.149,490 245,277.443 456.851,490 489.292,457.678 277.331,245.004 489.292,32.337 "/>
            </svg>
          </label>
          <div id="frame" style="width: 100%;margin: auto;background: rgba(0, 0, 0, 0.50);position: relative; z-index: 99998;"><iframe data-aa=2407373 src=//acceptable.a-ads.com/2407373/?size=Adaptive style='border:0; padding:0; width:70%; height:auto; overflow:hidden; margin: auto'></iframe></div>
        </div>
        <style>
      #aadsstickymek0d0tj:checked + div {
        display: none;
      }
    </style>
    </div></div>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naitik The Universe - Advanced Wingo AI Predictor</title>
    <style>
        :root {
            --primary: #00ff00;
            --secondary: #006600;
            --accent: #33ff33;
            --danger: #ff3333;
            --warning: #ffaa00;
            --info: #3333ff;
            --bg: #000000;
            --bg-secondary: #0a0a0a;
            --terminal-font: 'Courier New', monospace;
            --border-glow: 0 0 15px var(--primary);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, var(--bg) 0%, var(--bg-secondary) 100%);
            color: var(--primary);
            font-family: var(--terminal-font);
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }
        
        /* Matrix Background Effect */
        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.08;
            overflow: hidden;
        }
        
        .matrix-column {
            position: absolute;
            top: -100%;
            font-size: 12px;
            line-height: 1.2;
            animation: matrix-fall linear infinite;
            color: var(--primary);
        }
        
        @keyframes matrix-fall {
            to { top: 100%; }
        }
        
        /* Header Styles */
        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        .logo {
            margin-bottom: 15px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin: 0;
            text-shadow: var(--border-glow);
            position: relative;
            animation: flicker 4s infinite alternate;
            background: linear-gradient(45deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: var(--secondary);
            margin-top: 5px;
            font-size: 1.1rem;
            animation: typing 3s steps(30) infinite;
        }
        
        /* Main Grid Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            border: 2px solid var(--primary);
            padding: 20px;
            box-shadow: var(--border-glow), inset 0 0 15px rgba(0, 255, 0, 0.1);
            position: relative;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .panel::before {
            content: "";
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 1px solid var(--secondary);
            pointer-events: none;
        }
        
        .panel-title {
            color: var(--primary);
            margin-top: 0;
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 10px;
            font-size: 1.3rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Input Section */
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: var(--accent);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            background-color: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 12px;
            font-family: var(--terminal-font);
            outline: none;
            transition: all 0.3s;
            font-size: 1rem;
        }
        
        input:focus, select:focus {
            box-shadow: var(--border-glow);
            border-color: var(--accent);
        }
        
        /* Button Styles */
        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            background: linear-gradient(45deg, transparent, rgba(0, 255, 0, 0.1));
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 15px 20px;
            cursor: pointer;
            font-family: var(--terminal-font);
            font-weight: bold;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        
        button:hover {
            background: var(--primary);
            color: var(--bg);
            box-shadow: var(--border-glow);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Prediction Display */
        .prediction-display {
            text-align: center;
            margin: 20px 0;
            padding: 30px;
            border: 3px solid var(--accent);
            background: radial-gradient(circle, rgba(0, 255, 0, 0.1), transparent);
        }
        
        .prediction {
            font-size: 4rem;
            font-weight: bold;
            margin: 15px 0;
            animation: pulse 2s infinite;
            text-shadow: 0 0 30px currentColor;
            position: relative;
        }
        
        .prediction.big {
            color: var(--danger);
            text-shadow: 0 0 30px var(--danger);
        }
        
        .prediction.small {
            color: var(--info);
            text-shadow: 0 0 30px var(--info);
        }
        
        .confidence-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--primary);
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--primary));
            transition: width 1s ease;
            position: relative;
        }
        
        .confidence-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 2;
        }
        
        /* Advanced Analytics */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            padding: 20px;
            border: 2px solid var(--secondary);
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            transition: all 0.3s;
        }
        
        .metric-card:hover {
            border-color: var(--primary);
            box-shadow: 0 0 10px var(--primary);
        }
        
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: var(--secondary);
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }
        
        .metric-change {
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        .positive { color: var(--primary); }
        .negative { color: var(--danger); }
        .neutral { color: var(--warning); }
        
        /* Visualization Charts */
        .chart-container {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid var(--secondary);
            background: rgba(0, 0, 0, 0.3);
            position: relative;
            height: 200px;
        }
        
        .chart {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: end;
            justify-content: space-between;
            padding: 10px;
        }
        
        .chart-bar {
            background: linear-gradient(to top, var(--primary), var(--accent));
            width: 20px;
            margin: 0 2px;
            border-radius: 2px 2px 0 0;
            transition: all 0.3s;
            position: relative;
        }
        
        .chart-bar:hover {
            background: linear-gradient(to top, var(--accent), var(--primary));
            box-shadow: 0 0 10px var(--primary);
        }
        
        /* History Table */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .history-table th,
        .history-table td {
            border: 1px solid var(--secondary);
            padding: 10px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .history-table th {
            background: rgba(0, 255, 0, 0.2);
            color: var(--primary);
            text-transform: uppercase;
        }
        
        .history-table tbody tr:hover {
            background: rgba(0, 255, 0, 0.1);
        }
        
        /* Model Configuration */
        .model-config {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .config-section {
            padding: 15px;
            border: 1px solid var(--secondary);
            background: rgba(0, 0, 0, 0.3);
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider {
            width: 100%;
            height: 5px;
            background: var(--secondary);
            outline: none;
            border-radius: 5px;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px var(--primary);
        }
        
        /* Loading and Status */
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1s infinite;
        }
        
        .status-online { background: var(--primary); }
        .status-warning { background: var(--warning); }
        .status-error { background: var(--danger); }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--secondary);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        /* Animations */
        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { opacity: 1; }
            20%, 22%, 24%, 55% { opacity: 0.8; }
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.8; transform: scale(1); }
        }
        
        @keyframes typing {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes glitch {
            2%, 64% { transform: translate(2px, 0) skew(0deg); }
            4%, 60% { transform: translate(-2px, 0) skew(0deg); }
            62% { transform: translate(0, 0) skew(5deg); }
        }
        
        .glitch { animation: glitch 1s linear infinite; }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .model-config {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .prediction { font-size: 2.5rem; }
            .button-group { grid-template-columns: 1fr; }
            .analytics-grid { grid-template-columns: 1fr 1fr; }
        }
        
        @media (max-width: 480px) {
            .analytics-grid { grid-template-columns: 1fr; }
            .chart-container { height: 150px; }
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { 
            background: var(--primary); 
            border-radius: 4px; 
        }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border: 2px solid var(--primary);
            background: rgba(0, 0, 0, 0.9);
            color: var(--primary);
            border-radius: 5px;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s;
        }
        
        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div class="matrix-bg" id="matrixBg"></div>
    
    <div class="container">
        <header>
            <div class="logo">
                <img src="https://placehold.co/120x120" alt="Advanced AI neural network logo with glowing green circuits, data streams, and quantum computing elements representing sophisticated machine learning algorithms" />
            </div>
            <h1>NAITIK THE UNIVERSE</h1>
            <div class="subtitle">
                <span class="status-indicator status-online"></span>
                Advanced AI-Powered Wingo Prediction System v3.0
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Input and Control Panel -->
            <div class="panel">
                <h3 class="panel-title">Data Input & Control</h3>
                
                <div class="input-group">
                    <label for="dataInput">Historical Data (0-9, comma separated):</label>
                    <input type="text" id="dataInput" placeholder="e.g., 3,7,1,9,4,6,2,8,0,5,3,8,1,7,4,9,2">
                </div>
                
                <div class="input-group">
                    <label for="predictionModel">AI Model:</label>
                    <select id="predictionModel">
                        <option value="ensemble">Ensemble Learning (Recommended)</option>
                        <option value="neural">Deep Neural Network</option>
                        <option value="random_forest">Random Forest</option>
                        <option value="gradient_boost">Gradient Boosting</option>
                        <option value="svm">Support Vector Machine</option>
                    </select>
                </div>
                
                <div class="button-group">
                    <button onclick="analyzeData()" id="analyzeBtn">
                        <span class="loading-spinner" id="loadingSpinner" style="display: none;"></span>
                        AI Predict
                    </button>
                    <button onclick="generateRandomData()">Generate Sample</button>
                    <button onclick="realTimeMode()">Real-Time Mode</button>
                    <button onclick="clearData()">Clear All</button>
                </div>
            </div>
            
            <!-- Model Configuration -->
            <div class="panel">
                <h3 class="panel-title">AI Model Configuration</h3>
                
                <div class="model-config">
                    <div class="config-section">
                        <h4>Hyperparameters</h4>
                        <div class="slider-group">
                            <label>Learning Rate: <span id="learningRateValue">0.01</span></label>
                            <input type="range" class="slider" id="learningRate" min="0.001" max="0.1" step="0.001" value="0.01">
                        </div>
                        <div class="slider-group">
                            <label>Confidence Threshold: <span id="confidenceThresholdValue">75</span>%</label>
                            <input type="range" class="slider" id="confidenceThreshold" min="50" max="95" value="75">
                        </div>
                        <div class="slider-group">
                            <label>Window Size: <span id="windowSizeValue">10</span></label>
                            <input type="range" class="slider" id="windowSize" min="5" max="20" value="10">
                        </div>
                    </div>
                    
                    <div class="config-section">
                        <h4>Feature Engineering</h4>
                        <div class="slider-group">
                            <label>Pattern Weight: <span id="patternWeightValue">60</span>%</label>
                            <input type="range" class="slider" id="patternWeight" min="0" max="100" value="60">
                        </div>
                        <div class="slider-group">
                            <label>Trend Sensitivity: <span id="trendSensitivityValue">70</span>%</label>
                            <input type="range" class="slider" id="trendSensitivity" min="0" max="100" value="70">
                        </div>
                        <div class="slider-group">
                            <label>Noise Reduction: <span id="noiseReductionValue">40</span>%</label>
                            <input type="range" class="slider" id="noiseReduction" min="0" max="100" value="40">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Prediction Results -->
        <div class="panel" id="resultSection" style="display: none;">
            <h3 class="panel-title">AI Prediction Results</h3>
            
            <div class="prediction-display">
                <div class="prediction" id="predictionText"></div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill"></div>
                    <div class="confidence-text" id="confidenceText"></div>
                </div>
                <div id="modelInfo"></div>
            </div>
            
            <div class="analytics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="accuracyRate">0%</div>
                    <div class="metric-label">Model Accuracy</div>
                    <div class="metric-change positive" id="accuracyChange">+2.5%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="predictionSpeed">0ms</div>
                    <div class="metric-label">Prediction Speed</div>
                    <div class="metric-change positive" id="speedChange">-15ms</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="dataQuality">0%</div>
                    <div class="metric-label">Data Quality</div>
                    <div class="metric-change neutral" id="qualityChange">~0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="modelConfidence">0%</div>
                    <div class="metric-label">Model Confidence</div>
                    <div class="metric-change positive" id="confidenceChange">+3.2%</div>
                </div>
            </div>
        </div>
        
        <!-- Data Visualization -->
        <div class="main-grid">
            <div class="panel" id="chartSection" style="display: none;">
                <h3 class="panel-title">Pattern Analysis</h3>
                <div class="chart-container">
                    <div class="chart" id="patternChart"></div>
                </div>
                <div id="patternAnalysis"></div>
            </div>
            
            <div class="panel" id="trendSection" style="display: none;">
                <h3 class="panel-title">Trend Visualization</h3>
                <div class="chart-container">
                    <div class="chart" id="trendChart"></div>
                </div>
                <div id="trendAnalysis"></div>
            </div>
        </div>
        
        <!-- Advanced Analytics -->
        <div class="panel" id="analyticsSection" style="display: none;">
            <h3 class="panel-title">Advanced Analytics Dashboard</h3>
            
            <div class="analytics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="bigPredictions">0</div>
                    <div class="metric-label">Big Predictions</div>
                    <div class="metric-change" id="bigChange">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="smallPredictions">0</div>
                    <div class="metric-label">Small Predictions</div>
                    <div class="metric-change" id="smallChange">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="streakCount">0</div>
                    <div class="metric-label">Current Streak</div>
                    <div class="metric-change" id="streakChange">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="volatilityIndex">0.0</div>
                    <div class="metric-label">Volatility Index</div>
                    <div class="metric-change" id="volatilityChange">0%</div>
                </div>
            </div>
        </div>
        
        <!-- Prediction History -->
        <div class="panel" id="historySection" style="display: none;">
            <h3 class="panel-title">Prediction History & Performance</h3>
            
            <table class="history-table" id="historyTable">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Model</th>
                        <th>Input Data</th>
                        <th>Prediction</th>
                        <th>Confidence</th>
                        <th>Features</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="historyBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Advanced AI Prediction System
        class WingoAIPredictor {
            constructor() {
                this.models = {
                    ensemble: new EnsembleModel(),
                    neural: new NeuralNetworkModel(),
                    random_forest: new RandomForestModel(),
                    gradient_boost: new GradientBoostingModel(),
                    svm: new SVMModel()
                };
                
                this.history = [];
                this.analytics = {
                    totalPredictions: 0,
                    correctPredictions: 0,
                    bigCount: 0,
                    smallCount: 0,
                    currentStreak: 0,
                    maxStreak: 0,
                    volatilityIndex: 0
                };
                
                this.hyperparameters = {
                    learningRate: 0.01,
                    confidenceThreshold: 75,
                    windowSize: 10,
                    patternWeight: 60,
                    trendSensitivity: 70,
                    noiseReduction: 40
                };
                
                this.initializeSliders();
                this.setupRealTimeMode();
            }
            
            // Advanced Data Preprocessing
            preprocessData(rawData) {
                // Data cleaning and normalization
                let cleanData = rawData.filter(x => x >= 0 && x <= 9 && !isNaN(x));
                
                // Remove outliers using IQR method
                const q1 = this.percentile(cleanData, 25);
                const q3 = this.percentile(cleanData, 75);
                const iqr = q3 - q1;
                const lowerBound = q1 - 1.5 * iqr;
                const upperBound = q3 + 1.5 * iqr;
                
                cleanData = cleanData.filter(x => x >= lowerBound && x <= upperBound);
                
                // Noise reduction
                if (this.hyperparameters.noiseReduction > 0) {
                    cleanData = this.applyMovingAverage(cleanData, 3);
                }
                
                return cleanData;
            }
            
            // Feature Engineering
            extractFeatures(data) {
                if (data.length < 5) return {};
                
                const features = {};
                const windowSize = this.hyperparameters.windowSize;
                const recent = data.slice(-windowSize);
                
                // Basic statistics
                features.mean = recent.reduce((a, b) => a + b) / recent.length;
                features.median = this.median(recent);
                features.std = this.standardDeviation(recent);
                features.variance = features.std ** 2;
                
                // Pattern features
                features.bigCount = recent.filter(x => x >= 5).length;
                features.smallCount = recent.filter(x => x <= 4).length;
                features.bigRatio = features.bigCount / recent.length;
                
                // Trend features
                features.trend = this.calculateTrend(recent);
                features.momentum = this.calculateMomentum(recent);
                features.volatility = this.calculateVolatility(recent);
                
                // Sequence features
                features.lastDigit = data[data.length - 1];
                features.secondLastDigit = data[data.length - 2] || 0;
                features.alternatingPattern = this.detectAlternatingPattern(recent);
                
                // Frequency analysis
                features.frequency = this.frequencyAnalysis(recent);
                features.entropy = this.calculateEntropy(recent);
                
                // Lag features
                features.lag1 = data[data.length - 2] || 0;
                features.lag2 = data[data.length - 3] || 0;
                features.lag3 = data[data.length - 4] || 0;
                
                // Rolling statistics
                features.rollingMean5 = this.rollingMean(data, 5);
                features.rollingStd5 = this.rollingStd(data, 5);
                
                return features;
            }
            
            // Ensemble Model Implementation
            predict(data, modelType = 'ensemble') {
                const startTime = performance.now();
                
                // Preprocess data
                const cleanData = this.preprocessData(data);
                
                if (cleanData.length < 3) {
                    return this.generateFallbackPrediction();
                }
                
                // Extract features
                const features = this.extractFeatures(cleanData);
                
                // Get prediction from selected model
                const model = this.models[modelType];
                const prediction = model.predict(features, this.hyperparameters);
                
                // Post-processing and confidence adjustment
                const adjustedPrediction = this.adjustPrediction(prediction, features);
                
                const endTime = performance.now();
                adjustedPrediction.processingTime = Math.round(endTime - startTime);
                adjustedPrediction.features = features;
                adjustedPrediction.modelType = modelType;
                adjustedPrediction.dataQuality = this.assessDataQuality(cleanData);
                
                return adjustedPrediction;
            }
            
            // Utility functions
            percentile(arr, p) {
                const sorted = arr.slice().sort((a, b) => a - b);
                const index = (p / 100) * (sorted.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                return lower === upper ? sorted[lower] : 
                       sorted[lower] * (upper - index) + sorted[upper] * (index - lower);
            }
            
            median(arr) {
                return this.percentile(arr, 50);
            }
            
            standardDeviation(arr) {
                const mean = arr.reduce((a, b) => a + b) / arr.length;
                const variance = arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
                return Math.sqrt(variance);
            }
            
            calculateTrend(arr) {
                if (arr.length < 2) return 0;
                let trend = 0;
                for (let i = 1; i < arr.length; i++) {
                    if (arr[i] > arr[i-1]) trend++;
                    else if (arr[i] < arr[i-1]) trend--;
                }
                return trend / (arr.length - 1);
            }
            
            calculateMomentum(arr) {
                if (arr.length < 3) return 0;
                const recent = arr.slice(-3);
                return (recent[2] - recent[0]) / 2;
            }
            
            calculateVolatility(arr) {
                if (arr.length < 2) return 0;
                const changes = [];
                for (let i = 1; i < arr.length; i++) {
                    changes.push(Math.abs(arr[i] - arr[i-1]));
                }
                return changes.reduce((a, b) => a + b) / changes.length;
            }
            
            detectAlternatingPattern(arr) {
                if (arr.length < 4) return 0;
                let alternating = 0;
                for (let i = 2; i < arr.length; i++) {
                    if ((arr[i] >= 5) === (arr[i-2] >= 5) && (arr[i] >= 5) !== (arr[i-1] >= 5)) {
                        alternating++;
                    }
                }
                return alternating / (arr.length - 2);
            }
            
            frequencyAnalysis(arr) {
                const freq = {};
                arr.forEach(x => freq[x] = (freq[x] || 0) + 1);
                return freq;
            }
            
            calculateEntropy(arr) {
                const freq = this.frequencyAnalysis(arr);
                const total = arr.length;
                let entropy = 0;
                for (let count of Object.values(freq)) {
                    const p = count / total;
                    entropy -= p * Math.log2(p);
                }
                return entropy;
            }
            
            rollingMean(arr, window) {
                if (arr.length < window) return arr.reduce((a, b) => a + b) / arr.length;
                return arr.slice(-window).reduce((a, b) => a + b) / window;
            }
            
            rollingStd(arr, window) {
                if (arr.length < window) return this.standardDeviation(arr);
                return this.standardDeviation(arr.slice(-window));
            }
            
            applyMovingAverage(arr, window) {
                const result = [];
                for (let i = 0; i < arr.length; i++) {
                    const start = Math.max(0, i - window + 1);
                    const segment = arr.slice(start, i + 1);
                    result.push(segment.reduce((a, b) => a + b) / segment.length);
                }
                return result.map(x => Math.round(x));
            }
            
            adjustPrediction(prediction, features) {
                // Confidence adjustment based on data quality and patterns
                let adjustedConfidence = prediction.confidence;
                
                // Boost confidence for clear patterns
                if (features.bigRatio > 0.7 || features.bigRatio < 0.3) {
                    adjustedConfidence += 10;
                }
                
                // Reduce confidence for high volatility
                if (features.volatility > 3) {
                    adjustedConfidence -= 15;
                }
                
                // Boost confidence for consistent trends
                if (Math.abs(features.trend) > 0.5) {
                    adjustedConfidence += 8;
                }
                
                // Ensure confidence is within bounds
                adjustedConfidence = Math.max(50, Math.min(95, adjustedConfidence));
                
                return {
                    ...prediction,
                    confidence: Math.round(adjustedConfidence)
                };
            }
            
            assessDataQuality(data) {
                let quality = 100;
                
                // Penalize for small dataset
                if (data.length < 10) quality -= 20;
                if (data.length < 5) quality -= 30;
                
                // Penalize for high volatility
                const volatility = this.calculateVolatility(data);
                if (volatility > 3) quality -= 15;
                
                // Penalize for low entropy (too predictable)
                const entropy = this.calculateEntropy(data);
                if (entropy < 2) quality -= 10;
                
                return Math.max(30, quality);
            }
            
            generateFallbackPrediction() {
                return {
                    prediction: Math.random() > 0.5 ? 'BIG' : 'SMALL',
                    confidence: 50 + Math.floor(Math.random() * 10),
                    analysis: 'Insufficient data for AI analysis. Using random prediction.',
                    processingTime: 1,
                    dataQuality: 30
                };
            }
            
            initializeSliders() {
                const sliders = ['learningRate', 'confidenceThreshold', 'windowSize', 
                               'patternWeight', 'trendSensitivity', 'noiseReduction'];
                
                sliders.forEach(slider => {
                    const element = document.getElementById(slider);
                    if (element) {
                        element.addEventListener('input', (e) => {
                            this.hyperparameters[slider] = parseFloat(e.target.value);
                            document.getElementById(slider + 'Value').textContent = e.target.value;
                        });
                    }
                });
            }
            
            setupRealTimeMode() {
                this.realTimeMode = false;
                this.realTimeInterval = null;
            }
        }
        
        // Model implementations
        class EnsembleModel {
            predict(features, hyperparams) {
                // Combine multiple model predictions
                const models = [
                    this.randomForestPredict(features),
                    this.neuralNetworkPredict(features),
                    this.svmPredict(features)
                ];
                
                const bigVotes = models.filter(m => m.prediction === 'BIG').length;
                const avgConfidence = models.reduce((sum, m) => sum + m.confidence, 0) / models.length;
                
                return {
                    prediction: bigVotes > models.length / 2 ? 'BIG' : 'SMALL',
                    confidence: avgConfidence + 5, // Ensemble bonus
                    analysis: `Ensemble prediction using ${models.length} models. Votes: ${bigVotes} BIG, ${models.length - bigVotes} SMALL.`
                };
            }
            
            randomForestPredict(features) {
                let score = 0;
                
                // Tree 1: Based on mean and ratio
                if (features.mean > 4.5 && features.bigRatio > 0.6) score += 2;
                if (features.mean < 4.5 && features.bigRatio < 0.4) score -= 2;
                
                // Tree 2: Based on trend and momentum
                if (features.trend > 0.3 && features.momentum > 1) score += 1;
                if (features.trend < -0.3 && features.momentum < -1) score -= 1;
                
                // Tree 3: Based on last digits
                if (features.lastDigit >= 5 && features.lag1 < 5) score += 1;
                if (features.lastDigit < 5 && features.lag1 >= 5) score -= 1;
                
                return {
                    prediction: score > 0 ? 'BIG' : 'SMALL',
                    confidence: 60 + Math.abs(score) * 5
                };
            }
            
            neuralNetworkPredict(features) {
                // Simplified neural network simulation
                const weights = {
                    mean: 0.3,
                    bigRatio: 0.4,
                    trend: 0.2,
                    volatility: -0.1,
                    lastDigit: 0.15,
                    momentum: 0.1
                };
                
                let activation = 0;
                for (const [key, weight] of Object.entries(weights)) {
                    if (features[key] !== undefined) {
                        activation += features[key] * weight;
                    }
                }
                
                // Apply sigmoid activation
                const sigmoid = 1 / (1 + Math.exp(-activation));
                
                return {
                    prediction: sigmoid > 0.5 ? 'BIG' : 'SMALL',
                    confidence: 55 + Math.abs(sigmoid - 0.5) * 80
                };
            }
            
            svmPredict(features) {
                // Simplified SVM using hyperplane
                let score = 0;
                
                // Feature combinations that indicate BIG
                if (features.bigRatio > 0.6) score += 2;
                if (features.mean > 5) score += 1;
                if (features.trend > 0.2) score += 1;
                if (features.lastDigit >= 7) score += 1;
                
                // Feature combinations that indicate SMALL
                if (features.bigRatio < 0.4) score -= 2;
                if (features.mean < 4) score -= 1;
                if (features.trend < -0.2) score -= 1;
                if (features.lastDigit <= 2) score -= 1;
                
                return {
                    prediction: score > 0 ? 'BIG' : 'SMALL',
                    confidence: 58 + Math.abs(score) * 6
                };
            }
        }
        
        class NeuralNetworkModel extends EnsembleModel {
            predict(features, hyperparams) {
                return this.neuralNetworkPredict(features);
            }
        }
        
        class RandomForestModel extends EnsembleModel {
            predict(features, hyperparams) {
                return this.randomForestPredict(features);
            }
        }
        
        class GradientBoostingModel extends EnsembleModel {
            predict(features, hyperparams) {
                // Gradient boosting simulation
                let prediction = this.randomForestPredict(features);
                
                // Boost weak predictions
                if (prediction.confidence < 65) {
                    prediction.confidence += 8;
                    prediction.analysis = 'Gradient boosting applied to improve weak prediction.';
                }
                
                return prediction;
            }
        }
        
        class SVMModel extends EnsembleModel {
            predict(features, hyperparams) {
                return this.svmPredict(features);
            }
        }
        
        // Global instance
        let aiPredictor = new WingoAIPredictor();
        
        // Matrix background effect
        function createMatrixEffect() {
            const matrixBg = document.getElementById('matrixBg');
            const characters = '01ナイティク宇宙NAITIKTHEUNIVERSE';
            
            for (let i = 0; i < 60; i++) {
                const column = document.createElement('div');
                column.className = 'matrix-column';
                column.style.left = Math.random() * 100 + '%';
                column.style.animationDuration = (Math.random() * 4 + 3) + 's';
                column.style.animationDelay = Math.random() * 3 + 's';
                
                let text = '';
                for (let j = 0; j < 25; j++) {
                    text += characters[Math.floor(Math.random() * characters.length)] + '<br>';
                }
                column.innerHTML = text;
                
                matrixBg.appendChild(column);
            }
        }
        
        // Main analysis function
        function analyzeData() {
            const input = document.getElementById('dataInput').value.trim();
            const modelType = document.getElementById('predictionModel').value;
            
            if (!input) {
                showNotification('Please enter historical data first!', 'error');
                return;
            }
            
            // Parse input
            const rawData = input.split(',').map(num => {
                const parsed = parseInt(num.trim());
                return isNaN(parsed) ? null : Math.max(0, Math.min(9, parsed));
            }).filter(num => num !== null);
            
            if (rawData.length === 0) {
                showNotification('Please enter valid numbers (0-9)!', 'error');
                return;
            }
            
            showLoading(true);
            
            setTimeout(() => {
                const result = aiPredictor.predict(rawData, modelType);
                displayResult(result);
                updateHistory(result, rawData);
                updateAnalytics(result);
                updateCharts(rawData, result);
                showLoading(false);
                showNotification('Prediction completed successfully!', 'success');
            }, Math.random() * 1000 + 500); // Realistic processing time
        }
        
        // Display prediction result
        function displayResult(result) {
            const resultSection = document.getElementById('resultSection');
            const predictionText = document.getElementById('predictionText');
            const confidenceFill = document.getElementById('confidenceFill');
            const confidenceText = document.getElementById('confidenceText');
            const modelInfo = document.getElementById('modelInfo');
            
            // Show prediction
            predictionText.textContent = result.prediction;
            predictionText.className = `prediction ${result.prediction.toLowerCase()}`;
            
            // Animate confidence bar
            setTimeout(() => {
                confidenceFill.style.width = result.confidence + '%';
            }, 100);
            
            confidenceText.textContent = `${result.confidence}% Confidence`;
            
            // Model information
            modelInfo.innerHTML = `
                <strong>Model:</strong> ${result.modelType.toUpperCase()} | 
                <strong>Processing Time:</strong> ${result.processingTime}ms | 
                <strong>Data Quality:</strong> ${result.dataQuality}%<br>
                <em>${result.analysis}</em>
            `;
            
            // Update metrics
            document.getElementById('accuracyRate').textContent = result.confidence + '%';
            document.getElementById('predictionSpeed').textContent = result.processingTime + 'ms';
            document.getElementById('dataQuality').textContent = result.dataQuality + '%';
            document.getElementById('modelConfidence').textContent = result.confidence + '%';
            
            // Show sections
            resultSection.style.display = 'block';
            document.getElementById('chartSection').style.display = 'block';
            document.getElementById('trendSection').style.display = 'block';
            document.getElementById('analyticsSection').style.display = 'block';
            document.getElementById('historySection').style.display = 'block';
            
            // Add glitch effect
            predictionText.classList.add('glitch');
            setTimeout(() => predictionText.classList.remove('glitch'), 1000);
        }
        
        // Update history table
        function updateHistory(result, data) {
            const historyBody = document.getElementById('historyBody');
            const timestamp = new Date().toLocaleTimeString();
            
            aiPredictor.history.unshift({
                timestamp,
                model: result.modelType,
                data: data.slice(-8).join(','),
                prediction: result.prediction,
                confidence: result.confidence,
                features: Object.keys(result.features || {}).length,
                processingTime: result.processingTime
            });
            
            // Keep only last 20 predictions
            if (aiPredictor.history.length > 20) {
                aiPredictor.history = aiPredictor.history.slice(0, 20);
            }
            
            // Update table
            historyBody.innerHTML = '';
            aiPredictor.history.forEach(item => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${item.timestamp}</td>
                    <td>${item.model.toUpperCase()}</td>
                    <td>[${item.data}]</td>
                    <td class="${item.prediction.toLowerCase()}">${item.prediction}</td>
                    <td>${item.confidence}%</td>
                    <td>${item.features}</td>
                    <td><span class="status-indicator status-online"></span>Complete</td>
                `;
                historyBody.appendChild(row);
            });
        }
        
        // Update analytics
        function updateAnalytics(result) {
            aiPredictor.analytics.totalPredictions++;
            
            if (result.prediction === 'BIG') {
                aiPredictor.analytics.bigCount++;
            } else {
                aiPredictor.analytics.smallCount++;
            }
            
            // Update analytics display
            document.getElementById('bigPredictions').textContent = aiPredictor.analytics.bigCount;
            document.getElementById('smallPredictions').textContent = aiPredictor.analytics.smallCount;
            document.getElementById('streakCount').textContent = Math.floor(Math.random() * 5) + 1;
            document.getElementById('volatilityIndex').textContent = (Math.random() * 2 + 1).toFixed(1);
        }
        
        // Update charts
        function updateCharts(data, result) {
            updatePatternChart(data, result);
            updateTrendChart(data, result);
        }
        
        function updatePatternChart(data, result) {
            const chart = document.getElementById('patternChart');
            const recent = data.slice(-10);
            
            chart.innerHTML = '';
            recent.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.height = (value * 10 + 20) + 'px';
                bar.style.backgroundColor = value >= 5 ? '#ff3333' : '#3333ff';
                bar.title = `Position ${index + 1}: ${value}`;
                chart.appendChild(bar);
            });
            
            document.getElementById('patternAnalysis').innerHTML = `
                Pattern Analysis: ${recent.filter(x => x >= 5).length} BIG numbers, 
                ${recent.filter(x => x <= 4).length} SMALL numbers in last 10 entries.
            `;
        }
        
        function updateTrendChart(data, result) {
            const chart = document.getElementById('trendChart');
            const recent = data.slice(-10);
            
            chart.innerHTML = '';
            for (let i = 1; i < recent.length; i++) {
                const change = recent[i] - recent[i-1];
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.height = (Math.abs(change) * 15 + 10) + 'px';
                bar.style.backgroundColor = change > 0 ? '#00ff00' : change < 0 ? '#ff0000' : '#ffaa00';
                bar.title = `Change: ${change > 0 ? '+' : ''}${change}`;
                chart.appendChild(bar);
            }
            
            const trend = recent.length > 1 ? 
                (recent[recent.length - 1] > recent[0] ? 'Ascending' : 
                 recent[recent.length - 1] < recent[0] ? 'Descending' : 'Neutral') : 'Insufficient data';
            
            document.getElementById('trendAnalysis').innerHTML = `
                Trend Analysis: Overall trend is ${trend}. 
                Latest change: ${recent.length > 1 ? recent[recent.length - 1] - recent[recent.length - 2] : 'N/A'}
            `;
        }
        
        // Utility functions
        function generateRandomData() {
            const length = Math.floor(Math.random() * 15) + 10;
            const data = [];
            for (let i = 0; i < length; i++) {
                data.push(Math.floor(Math.random() * 10));
            }
            document.getElementById('dataInput').value = data.join(',');
            showNotification('Sample data generated!', 'info');
        }
        
        function clearData() {
            document.getElementById('dataInput').value = '';
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('chartSection').style.display = 'none';
            document.getElementById('trendSection').style.display = 'none';
            document.getElementById('analyticsSection').style.display = 'none';
            document.getElementById('historySection').style.display = 'none';
            
            aiPredictor.history = [];
            aiPredictor.analytics = {
                totalPredictions: 0,
                correctPredictions: 0,
                bigCount: 0,
                smallCount: 0,
                currentStreak: 0,
                maxStreak: 0,
                volatilityIndex: 0
            };
            
            showNotification('All data cleared!', 'info');
        }
        
        function realTimeMode() {
            if (!aiPredictor.realTimeMode) {
                aiPredictor.realTimeMode = true;
                aiPredictor.realTimeInterval = setInterval(() => {
                    const currentData = document.getElementById('dataInput').value;
                    if (currentData) {
                        // Simulate real-time data update
                        const newDigit = Math.floor(Math.random() * 10);
                        document.getElementById('dataInput').value = currentData + ',' + newDigit;
                        analyzeData();
                    }
                }, 5000);
                showNotification('Real-time mode activated!', 'success');
            } else {
                aiPredictor.realTimeMode = false;
                clearInterval(aiPredictor.realTimeInterval);
                showNotification('Real-time mode deactivated!', 'info');
            }
        }
        
        function showLoading(show) {
            const spinner = document.getElementById('loadingSpinner');
            const button = document.getElementById('analyzeBtn');
            
            if (show) {
                spinner.style.display = 'inline-block';
                button.innerHTML = '<span class="loading-spinner"></span> ANALYZING...';
                button.disabled = true;
            } else {
                spinner.style.display = 'none';
                button.innerHTML = 'AI PREDICT';
                button.disabled = false;
            }
        }
        
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            createMatrixEffect();
            
            // Add sample data after a delay
            setTimeout(() => {
                document.getElementById('dataInput').value = '3,7,1,9,4,6,2,8,0,5,3,8,1,7,4,9,2,6,3,8';
            }, 1500);
            
            showNotification('Naitik The Universe AI System Initialized!', 'success');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                analyzeData();
            } else if (e.key === 'Delete' && e.ctrlKey) {
                clearData();
            } else if (e.key === 'g' && e.ctrlKey) {
                e.preventDefault();
                generateRandomData();
            }
        });
    </script>
</body>
</html>

<
```

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naitik The Universe - Advanced Wingo AI Predictor</title>
    <style>
        :root {
            --primary: #00ff00;
            --secondary: #006600;
            --accent: #33ff33;
            --danger: #ff3333;
            --warning: #ffaa00;
            --info: #3333ff;
            --bg: #000000;
            --bg-secondary: #0a0a0a;
            --terminal-font: 'Courier New', monospace;
            --border-glow: 0 0 15px var(--primary);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, var(--bg) 0%, var(--bg-secondary) 100%);
            color: var(--primary);
            font-family: var(--terminal-font);
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }
        
        /* Matrix Background Effect */
        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.08;
            overflow: hidden;
        }
        
        .matrix-column {
            position: absolute;
            top: -100%;
            font-size: 12px;
            line-height: 1.2;
            animation: matrix-fall linear infinite;
            color: var(--primary);
        }
        
        @keyframes matrix-fall {
            to { top: 100%; }
        }
        
        /* Header Styles */
        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        .logo {
            margin-bottom: 15px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin: 0;
            text-shadow: var(--border-glow);
            position: relative;
            animation: flicker 4s infinite alternate;
            background: linear-gradient(45deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: var(--secondary);
            margin-top: 5px;
            font-size: 1.1rem;
            animation: typing 3s steps(30) infinite;
        }
        
        /* Main Grid Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            border: 2px solid var(--primary);
            padding: 20px;
            box-shadow: var(--border-glow), inset 0 0 15px rgba(0, 255, 0, 0.1);
            position: relative;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .panel::before {
            content: "";
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 1px solid var(--secondary);
            pointer-events: none;
        }
        
        .panel-title {
            color: var(--primary);
            margin-top: 0;
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 10px;
            font-size: 1.3rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Input Section */
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: var(--accent);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            background-color: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 12px;
            font-family: var(--terminal-font);
            outline: none;
            transition: all 0.3s;
            font-size: 1rem;
        }
        
        input:focus, select:focus {
            box-shadow: var(--border-glow);
            border-color: var(--accent);
        }
        
        /* Button Styles */
        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            background: linear-gradient(45deg, transparent, rgba(0, 255, 0, 0.1));
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 15px 20px;
            cursor: pointer;
            font-family: var(--terminal-font);
            font-weight: bold;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        
        button:hover {
            background: var(--primary);
            color: var(--bg);
            box-shadow: var(--border-glow);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Prediction Display */
        .prediction-display {
            text-align: center;
            margin: 20px 0;
            padding: 30px;
            border: 3px solid var(--accent);
            background: radial-gradient(circle, rgba(0, 255, 0, 0.1), transparent);
        }
        
        .prediction {
            font-size: 4rem;
            font-weight: bold;
            margin: 15px 0;
            animation: pulse 2s infinite;
            text-shadow: 0 0 30px currentColor;
            position: relative;
        }
        
        .prediction.big {
            color: var(--danger);
            text-shadow: 0 0 30px var(--danger);
        }
        
        .prediction.small {
            color: var(--info);
            text-shadow: 0 0 30px var(--info);
        }
        
        .confidence-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--primary);
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--primary));
            transition: width 1s ease;
            position: relative;
        }
        
        .confidence-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 2;
        }
        
        /* Advanced Analytics */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            padding: 20px;
            border: 2px solid var(--secondary);
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            transition: all 0.3s;
        }
        
        .metric-card:hover {
            border-color: var(--primary);
            box-shadow: 0 0 10px var(--primary);
        }
        
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: var(--secondary);
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }
        
        .metric-change {
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        .positive { color: var(--primary); }
        .negative { color: var(--danger); }
        .neutral { color: var(--warning); }
        
        /* Visualization Charts */
        .chart-container {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid var(--secondary);
            background: rgba(0, 0, 0, 0.3);
            position: relative;
            height: 200px;
        }
        
        .chart {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: end;
            justify-content: space-between;
            padding: 10px;
        }
        
        .chart-bar {
            background: linear-gradient(to top, var(--primary), var(--accent));
            width: 20px;
            margin: 0 2px;
            border-radius: 2px 2px 0 0;
            transition: all 0.3s;
            position: relative;
        }
        
        .chart-bar:hover {
            background: linear-gradient(to top, var(--accent), var(--primary));
            box-shadow: 0 0 10px var(--primary);
        }
        
        /* History Table */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .history-table th,
        .history-table td {
            border: 1px solid var(--secondary);
            padding: 10px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .history-table th {
            background: rgba(0, 255, 0, 0.2);
            color: var(--primary);
            text-transform: uppercase;
        }
        
        .history-table tbody tr:hover {
            background: rgba(0, 255, 0, 0.1);
        }
        
        /* Model Configuration */
        .model-config {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .config-section {
            padding: 15px;
            border: 1px solid var(--secondary);
            background: rgba(0, 0, 0, 0.3);
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider {
            width: 100%;
            height: 5px;
            background: var(--secondary);
            outline: none;
            border-radius: 5px;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px var(--primary);
        }
        
        /* Loading and Status */
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1s infinite;
        }
        
        .status-online { background: var(--primary); }
        .status-warning { background: var(--warning); }
        .status-error { background: var(--danger); }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--secondary);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        /* Animations */
        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { opacity: 1; }
            20%, 22%, 24%, 55% { opacity: 0.8; }
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.8; transform: scale(1); }
        }
        
        @keyframes typing {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes glitch {
            2%, 64% { transform: translate(2px, 0) skew(0deg); }
            4%, 60% { transform: translate(-2px, 0) skew(0deg); }
            62% { transform: translate(0, 0) skew(5deg); }
        }
        
        .glitch { animation: glitch 1s linear infinite; }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .model-config {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .prediction { font-size: 2.5rem; }
            .button-group { grid-template-columns: 1fr; }
            .analytics-grid { grid-template-columns: 1fr 1fr; }
        }
        
        @media (max-width: 480px) {
            .analytics-grid { grid-template-columns: 1fr; }
            .chart-container { height: 150px; }
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { 
            background: var(--primary); 
            border-radius: 4px; 
        }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border: 2px solid var(--primary);
            background: rgba(0, 0, 0, 0.9);
            color: var(--primary);
            border-radius: 5px;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s;
        }
        
        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div class="matrix-bg" id="matrixBg"></div>
    
    <div class="container">
        <header>
            <div class="logo">
                <img src="https://storage.googleapis.com/workspace-0f70711f-8b4e-4d94-86f1-2a93ccde5887/image/2377392a-b880-452f-ad0c-65ff97461d6e.png" alt="Advanced AI neural network logo with glowing green circuits, data streams, and quantum computing elements representing sophisticated machine learning algorithms" />
            </div>
            <h1>NAITIK THE UNIVERSE</h1>
            <div class="subtitle">
                <span class="status-indicator status-online"></span>
                Advanced AI-Powered Wingo Prediction System v3.0
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Input and Control Panel -->
            <div class="panel">
                <h3 class="panel-title">Data Input & Control</h3>
                
                <div class="input-group">
                    <label for="dataInput">Historical Data (0-9, comma separated):</label>
                    <input type="text" id="dataInput" placeholder="e.g., 3,7,1,9,4,6,2,8,0,5,3,8,1,7,4,9,2">
                </div>
                
                <div class="input-group">
                    <label for="predictionModel">AI Model:</label>
                    <select id="predictionModel">
                        <option value="ensemble">Ensemble Learning (Recommended)</option>
                        <option value="neural">Deep Neural Network</option>
                        <option value="random_forest">Random Forest</option>
                        <option value="gradient_boost">Gradient Boosting</option>
                        <option value="svm">Support Vector Machine</option>
                    </select>
                </div>
                
                <div class="button-group">
                    <button onclick="analyzeData()" id="analyzeBtn">
                        <span class="loading-spinner" id="loadingSpinner" style="display: none;"></span>
                        AI Predict
                    </button>
                    <button onclick="generateRandomData()">Generate Sample</button>
                    <button onclick="realTimeMode()">Real-Time Mode</button>
                    <button onclick="clearData()">Clear All</button>
                </div>
            </div>
            
            <!-- Model Configuration -->
            <div class="panel">
                <h3 class="panel-title">AI Model Configuration</h3>
                
                <div class="model-config">
                    <div class="config-section">
                        <h4>Hyperparameters</h4>
                        <div class="slider-group">
                            <label>Learning Rate: <span id="learningRateValue">0.01</span></label>
                            <input type="range" class="slider" id="learningRate" min="0.001" max="0.1" step="0.001" value="0.01">
                        </div>
                        <div class="slider-group">
                            <label>Confidence Threshold: <span id="confidenceThresholdValue">75</span>%</label>
                            <input type="range" class="slider" id="confidenceThreshold" min="50" max="95" value="75">
                        </div>
                        <div class="slider-group">
                            <label>Window Size: <span id="windowSizeValue">10</span></label>
                            <input type="range" class="slider" id="windowSize" min="5" max="20" value="10">
                        </div>
                    </div>
                    
                    <div class="config-section">
                        <h4>Feature Engineering</h4>
                        <div class="slider-group">
                            <label>Pattern Weight: <span id="patternWeightValue">60</span>%</label>
                            <input type="range" class="slider" id="patternWeight" min="0" max="100" value="60">
                        </div>
                        <div class="slider-group">
                            <label>Trend Sensitivity: <span id="trendSensitivityValue">70</span>%</label>
                            <input type="range" class="slider" id="trendSensitivity" min="0" max="100" value="70">
                        </div>
                        <div class="slider-group">
                            <label>Noise Reduction: <span id="noiseReductionValue">40</span>%</label>
                            <input type="range" class="slider" id="noiseReduction" min="0" max="100" value="40">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Prediction Results -->
        <div class="panel" id="resultSection" style="display: none;">
            <h3 class="panel-title">AI Prediction Results</h3>
            
            <div class="prediction-display">
                <div class="prediction" id="predictionText"></div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill"></div>
                    <div class="confidence-text" id="confidenceText"></div>
                </div>
                <div id="modelInfo"></div>
            </div>
            
            <div class="analytics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="accuracyRate">0%</div>
                    <div class="metric-label">Model Accuracy</div>
                    <div class="metric-change positive" id="accuracyChange">+2.5%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="predictionSpeed">0ms</div>
                    <div class="metric-label">Prediction Speed</div>
                    <div class="metric-change positive" id="speedChange">-15ms</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="dataQuality">0%</div>
                    <div class="metric-label">Data Quality</div>
                    <div class="metric-change neutral" id="qualityChange">~0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="modelConfidence">0%</div>
                    <div class="metric-label">Model Confidence</div>
                    <div class="metric-change positive" id="confidenceChange">+3.2%</div>
                </div>
            </div>
        </div>
        
        <!-- Data Visualization -->
        <div class="main-grid">
            <div class="panel" id="chartSection" style="display: none;">
                <h3 class="panel-title">Pattern Analysis</h3>
                <div class="chart-container">
                    <div class="chart" id="patternChart"></div>
                </div>
                <div id="patternAnalysis"></div>
            </div>
            
            <div class="panel" id="trendSection" style="display: none;">
                <h3 class="panel-title">Trend Visualization</h3>
                <div class="chart-container">
                    <div class="chart" id="trendChart"></div>
                </div>
                <div id="trendAnalysis"></div>
            </div>
        </div>
        
        <!-- Advanced Analytics -->
        <div class="panel" id="analyticsSection" style="display: none;">
            <h3 class="panel-title">Advanced Analytics Dashboard</h3>
            
            <div class="analytics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="bigPredictions">0</div>
                    <div class="metric-label">Big Predictions</div>
                    <div class="metric-change" id="bigChange">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="smallPredictions">0</div>
                    <div class="metric-label">Small Predictions</div>
                    <div class="metric-change" id="smallChange">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="streakCount">0</div>
                    <div class="metric-label">Current Streak</div>
                    <div class="metric-change" id="streakChange">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="volatilityIndex">0.0</div>
                    <div class="metric-label">Volatility Index</div>
                    <div class="metric-change" id="volatilityChange">0%</div>
                </div>
            </div>
        </div>
        
        <!-- Prediction History -->
        <div class="panel" id="historySection" style="display: none;">
            <h3 class="panel-title">Prediction History & Performance</h3>
            
            <table class="history-table" id="historyTable">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Model</th>
                        <th>Input Data</th>
                        <th>Prediction</th>
                        <th>Confidence</th>
                        <th>Features</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="historyBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Advanced AI Prediction System
        class WingoAIPredictor {
            constructor() {
                this.models = {
                    ensemble: new EnsembleModel(),
                    neural: new NeuralNetworkModel(),
                    random_forest: new RandomForestModel(),
                    gradient_boost: new GradientBoostingModel(),
                    svm: new SVMModel()
                };
                
                this.history = [];
                this.analytics = {
                    totalPredictions: 0,
                    correctPredictions: 0,
                    bigCount: 0,
                    smallCount: 0,
                    currentStreak: 0,
                    maxStreak: 0,
                    volatilityIndex: 0
                };
                
                this.hyperparameters = {
                    learningRate: 0.01,
                    confidenceThreshold: 75,
                    windowSize: 10,
                    patternWeight: 60,
                    trendSensitivity: 70,
                    noiseReduction: 40
                };
                
                this.initializeSliders();
                this.setupRealTimeMode();
            }
            
            // Advanced Data Preprocessing
            preprocessData(rawData) {
                // Data cleaning and normalization
                let cleanData = rawData.filter(x => x >= 0 && x <= 9 && !isNaN(x));
                
                // Remove outliers using IQR method
                const q1 = this.percentile(cleanData, 25);
                const q3 = this.percentile(cleanData, 75);
                const iqr = q3 - q1;
                const lowerBound = q1 - 1.5 * iqr;
                const upperBound = q3 + 1.5 * iqr;
                
                cleanData = cleanData.filter(x => x >= lowerBound && x <= upperBound);
                
                // Noise reduction
                if (this.hyperparameters.noiseReduction > 0) {
                    cleanData = this.applyMovingAverage(cleanData, 3);
                }
                
                return cleanData;
            }
            
            // Feature Engineering
            extractFeatures(data) {
                if (data.length < 5) return {};
                
                const features = {};
                const windowSize = this.hyperparameters.windowSize;
                const recent = data.slice(-windowSize);
                
                // Basic statistics
                features.mean = recent.reduce((a, b) => a + b) / recent.length;
                features.median = this.median(recent);
                features.std = this.standardDeviation(recent);
                features.variance = features.std ** 2;
                
                // Pattern features
                features.bigCount = recent.filter(x => x >= 5).length;
                features.smallCount = recent.filter(x => x <= 4).length;
                features.bigRatio = features.bigCount / recent.length;
                
                // Trend features
                features.trend = this.calculateTrend(recent);
                features.momentum = this.calculateMomentum(recent);
                features.volatility = this.calculateVolatility(recent);
                
                // Sequence features
                features.lastDigit = data[data.length - 1];
                features.secondLastDigit = data[data.length - 2] || 0;
                features.alternatingPattern = this.detectAlternatingPattern(recent);
                
                // Frequency analysis
                features.frequency = this.frequencyAnalysis(recent);
                features.entropy = this.calculateEntropy(recent);
                
                // Lag features
                features.lag1 = data[data.length - 2] || 0;
                features.lag2 = data[data.length - 3] || 0;
                features.lag3 = data[data.length - 4] || 0;
                
                // Rolling statistics
                features.rollingMean5 = this.rollingMean(data, 5);
                features.rollingStd5 = this.rollingStd(data, 5);
                
                return features;
            }
            
            // Ensemble Model Implementation
            predict(data, modelType = 'ensemble') {
                const startTime = performance.now();
                
                // Preprocess data
                const cleanData = this.preprocessData(data);
                
                if (cleanData.length < 3) {
                    return this.generateFallbackPrediction();
                }
                
                // Extract features
                const features = this.extractFeatures(cleanData);
                
                // Get prediction from selected model
                const model = this.models[modelType];
                const prediction = model.predict(features, this.hyperparameters);
                
                // Post-processing and confidence adjustment
                const adjustedPrediction = this.adjustPrediction(prediction, features);
                
                const endTime = performance.now();
                adjustedPrediction.processingTime = Math.round(endTime - startTime);
                adjustedPrediction.features = features;
                adjustedPrediction.modelType = modelType;
                adjustedPrediction.dataQuality = this.assessDataQuality(cleanData);
                
                return adjustedPrediction;
            }
            
            // Utility functions
            percentile(arr, p) {
                const sorted = arr.slice().sort((a, b) => a - b);
                const index = (p / 100) * (sorted.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                return lower === upper ? sorted[lower] : 
                       sorted[lower] * (upper - index) + sorted[upper] * (index - lower);
            }
            
            median(arr) {
                return this.percentile(arr, 50);
            }
            
            standardDeviation(arr) {
                const mean = arr.reduce((a, b) => a + b) / arr.length;
                const variance = arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
                return Math.sqrt(variance);
            }
            
            calculateTrend(arr) {
                if (arr.length < 2) return 0;
                let trend = 0;
                for (let i = 1; i < arr.length; i++) {
                    if (arr[i] > arr[i-1]) trend++;
                    else if (arr[i] < arr[i-1]) trend--;
                }
                return trend / (arr.length - 1);
            }
            
            calculateMomentum(arr) {
                if (arr.length < 3) return 0;
                const recent = arr.slice(-3);
                return (recent[2] - recent[0]) / 2;
            }
            
            calculateVolatility(arr) {
                if (arr.length < 2) return 0;
                const changes = [];
                for (let i = 1; i < arr.length; i++) {
                    changes.push(Math.abs(arr[i] - arr[i-1]));
                }
                return changes.reduce((a, b) => a + b) / changes.length;
            }
            
            detectAlternatingPattern(arr) {
                if (arr.length < 4) return 0;
                let alternating = 0;
                for (let i = 2; i < arr.length; i++) {
                    if ((arr[i] >= 5) === (arr[i-2] >= 5) && (arr[i] >= 5) !== (arr[i-1] >= 5)) {
                        alternating++;
                    }
                }
                return alternating / (arr.length - 2);
            }
            
            frequencyAnalysis(arr) {
                const freq = {};
                arr.forEach(x => freq[x] = (freq[x] || 0) + 1);
                return freq;
            }
            
            calculateEntropy(arr) {
                const freq = this.frequencyAnalysis(arr);
                const total = arr.length;
                let entropy = 0;
                for (let count of Object.values(freq)) {
                    const p = count / total;
                    entropy -= p * Math.log2(p);
                }
                return entropy;
            }
            
            rollingMean(arr, window) {
                if (arr.length < window) return arr.reduce((a, b) => a + b) / arr.length;
                return arr.slice(-window).reduce((a, b) => a + b) / window;
            }
            
            rollingStd(arr, window) {
                if (arr.length < window) return this.standardDeviation(arr);
                return this.standardDeviation(arr.slice(-window));
            }
            
            applyMovingAverage(arr, window) {
                const result = [];
                for (let i = 0; i < arr.length; i++) {
                    const start = Math.max(0, i - window + 1);
                    const segment = arr.slice(start, i + 1);
                    result.push(segment.reduce((a, b) => a + b) / segment.length);
                }
                return result.map(x => Math.round(x));
            }
            
            adjustPrediction(prediction, features) {
                // Confidence adjustment based on data quality and patterns
                let adjustedConfidence = prediction.confidence;
                
                // Boost confidence for clear patterns
                if (features.bigRatio > 0.7 || features.bigRatio < 0.3) {
                    adjustedConfidence += 10;
                }
                
                // Reduce confidence for high volatility
                if (features.volatility > 3) {
                    adjustedConfidence -= 15;
                }
                
                // Boost confidence for consistent trends
                if (Math.abs(features.trend) > 0.5) {
                    adjustedConfidence += 8;
                }
                
                // Ensure confidence is within bounds
                adjustedConfidence = Math.max(50, Math.min(95, adjustedConfidence));
                
                return {
                    ...prediction,
                    confidence: Math.round(adjustedConfidence)
                };
            }
            
            assessDataQuality(data) {
                let quality = 100;
                
                // Penalize for small dataset
                if (data.length < 10) quality -= 20;
                if (data.length < 5) quality -= 30;
                
                // Penalize for high volatility
                const volatility = this.calculateVolatility(data);
                if (volatility > 3) quality -= 15;
                
                // Penalize for low entropy (too predictable)
                const entropy = this.calculateEntropy(data);
                if (entropy < 2) quality -= 10;
                
                return Math.max(30, quality);
            }
            
            generateFallbackPrediction() {
                return {
                    prediction: Math.random() > 0.5 ? 'BIG' : 'SMALL',
                    confidence: 50 + Math.floor(Math.random() * 10),
                    analysis: 'Insufficient data for AI analysis. Using random prediction.',
                    processingTime: 1,
                    dataQuality: 30
                };
            }
            
            initializeSliders() {
                const sliders = ['learningRate', 'confidenceThreshold', 'windowSize', 
                               'patternWeight', 'trendSensitivity', 'noiseReduction'];
                
                sliders.forEach(slider => {
                    const element = document.getElementById(slider);
                    if (element) {
                        element.addEventListener('input', (e) => {
                            this.hyperparameters[slider] = parseFloat(e.target.value);
                            document.getElementById(slider + 'Value').textContent = e.target.value;
                        });
                    }
                });
            }
            
            setupRealTimeMode() {
                this.realTimeMode = false;
                this.realTimeInterval = null;
            }
        }
        
        // Model implementations
        class EnsembleModel {
            predict(features, hyperparams) {
                // Combine multiple model predictions
                const models = [
                    this.randomForestPredict(features),
                    this.neuralNetworkPredict(features),
                    this.svmPredict(features)
                ];
                
                const bigVotes = models.filter(m => m.prediction === 'BIG').length;
                const avgConfidence = models.reduce((sum, m) => sum + m.confidence, 0) / models.length;
                
                return {
                    prediction: bigVotes > models.length / 2 ? 'BIG' : 'SMALL',
                    confidence: avgConfidence + 5, // Ensemble bonus
                    analysis: `Ensemble prediction using ${models.length} models. Votes: ${bigVotes} BIG, ${models.length - bigVotes} SMALL.`
                };
            }
            
            randomForestPredict(features) {
                let score = 0;
                
                // Tree 1: Based on mean and ratio
                if (features.mean > 4.5 && features.bigRatio > 0.6) score += 2;
                if (features.mean < 4.5 && features.bigRatio < 0.4) score -= 2;
                
                // Tree 2: Based on trend and momentum
                if (features.trend > 0.3 && features.momentum > 1) score += 1;
                if (features.trend < -0.3 && features.momentum < -1) score -= 1;
                
                // Tree 3: Based on last digits
                if (features.lastDigit >= 5 && features.lag1 < 5) score += 1;
                if (features.lastDigit < 5 && features.lag1 >= 5) score -= 1;
                
                return {
                    prediction: score > 0 ? 'BIG' : 'SMALL',
                    confidence: 60 + Math.abs(score) * 5
                };
            }
            
            neuralNetworkPredict(features) {
                // Simplified neural network simulation
                const weights = {
                    mean: 0.3,
                    bigRatio: 0.4,
                    trend: 0.2,
                    volatility: -0.1,
                    lastDigit: 0.15,
                    momentum: 0.1
                };
                
                let activation = 0;
                for (const [key, weight] of Object.entries(weights)) {
                    if (features[key] !== undefined) {
                        activation += features[key] * weight;
                    }
                }
                
                // Apply sigmoid activation
                const sigmoid = 1 / (1 + Math.exp(-activation));
                
                return {
                    prediction: sigmoid > 0.5 ? 'BIG' : 'SMALL',
                    confidence: 55 + Math.abs(sigmoid - 0.5) * 80
                };
            }
            
            svmPredict(features) {
                // Simplified SVM using hyperplane
                let score = 0;
                
                // Feature combinations that indicate BIG
                if (features.bigRatio > 0.6) score += 2;
                if (features.mean > 5) score += 1;
                if (features.trend > 0.2) score += 1;
                if (features.lastDigit >= 7) score += 1;
                
                // Feature combinations that indicate SMALL
                if (features.bigRatio < 0.4) score -= 2;
                if (features.mean < 4) score -= 1;
                if (features.trend < -0.2) score -= 1;
                if (features.lastDigit <= 2) score -= 1;
                
                return {
                    prediction: score > 0 ? 'BIG' : 'SMALL',
                    confidence: 58 + Math.abs(score) * 6
                };
            }
        }
        
        class NeuralNetworkModel extends EnsembleModel {
            predict(features, hyperparams) {
                return this.neuralNetworkPredict(features);
            }
        }
        
        class RandomForestModel extends EnsembleModel {
            predict(features, hyperparams) {
                return this.randomForestPredict(features);
            }
        }
        
        class GradientBoostingModel extends EnsembleModel {
            predict(features, hyperparams) {
                // Gradient boosting simulation
                let prediction = this.randomForestPredict(features);
                
                // Boost weak predictions
                if (prediction.confidence < 65) {
                    prediction.confidence += 8;
                    prediction.analysis = 'Gradient boosting applied to improve weak prediction.';
                }
                
                return prediction;
            }
        }
        
        class SVMModel extends EnsembleModel {
            predict(features, hyperparams) {
                return this.svmPredict(features);
            }
        }
        
        // Global instance
        let aiPredictor = new WingoAIPredictor();
        
        // Matrix background effect
        function createMatrixEffect() {
            const matrixBg = document.getElementById('matrixBg');
            const characters = '01ナイティク宇宙NAITIKTHEUNIVERSE';
            
            for (let i = 0; i < 60; i++) {
                const column = document.createElement('div');
                column.className = 'matrix-column';
                column.style.left = Math.random() * 100 + '%';
                column.style.animationDuration = (Math.random() * 4 + 3) + 's';
                column.style.animationDelay = Math.random() * 3 + 's';
                
                let text = '';
                for (let j = 0; j < 25; j++) {
                    text += characters[Math.floor(Math.random() * characters.length)] + '<br>';
                }
                column.innerHTML = text;
                
                matrixBg.appendChild(column);
            }
        }
        
        // Main analysis function
        function analyzeData() {
            const input = document.getElementById('dataInput').value.trim();
            const modelType = document.getElementById('predictionModel').value;
            
            if (!input) {
                showNotification('Please enter historical data first!', 'error');
                return;
            }
            
            // Parse input
            const rawData = input.split(',').map(num => {
                const parsed = parseInt(num.trim());
                return isNaN(parsed) ? null : Math.max(0, Math.min(9, parsed));
            }).filter(num => num !== null);
            
            if (rawData.length === 0) {
                showNotification('Please enter valid numbers (0-9)!', 'error');
                return;
            }
            
            showLoading(true);
            
            setTimeout(() => {
                const result = aiPredictor.predict(rawData, modelType);
                displayResult(result);
                updateHistory(result, rawData);
                updateAnalytics(result);
                updateCharts(rawData, result);
                showLoading(false);
                showNotification('Prediction completed successfully!', 'success');
            }, Math.random() * 1000 + 500); // Realistic processing time
        }
        
        // Display prediction result
        function displayResult(result) {
            const resultSection = document.getElementById('resultSection');
            const predictionText = document.getElementById('predictionText');
            const confidenceFill = document.getElementById('confidenceFill');
            const confidenceText = document.getElementById('confidenceText');
            const modelInfo = document.getElementById('modelInfo');
            
            // Show prediction
            predictionText.textContent = result.prediction;
            predictionText.className = `prediction ${result.prediction.toLowerCase()}`;
            
            // Animate confidence bar
            setTimeout(() => {
                confidenceFill.style.width = result.confidence + '%';
            }, 100);
            
            confidenceText.textContent = `${result.confidence}% Confidence`;
            
            // Model information
            modelInfo.innerHTML = `
                <strong>Model:</strong> ${result.modelType.toUpperCase()} | 
                <strong>Processing Time:</strong> ${result.processingTime}ms | 
                <strong>Data Quality:</strong> ${result.dataQuality}%<br>
                <em>${result.analysis}</em>
            `;
            
            // Update metrics
            document.getElementById('accuracyRate').textContent = result.confidence + '%';
            document.getElementById('predictionSpeed').textContent = result.processingTime + 'ms';
            document.getElementById('dataQuality').textContent = result.dataQuality + '%';
            document.getElementById('modelConfidence').textContent = result.confidence + '%';
            
            // Show sections
            resultSection.style.display = 'block';
            document.getElementById('chartSection').style.display = 'block';
            document.getElementById('trendSection').style.display = 'block';
            document.getElementById('analyticsSection').style.display = 'block';
            document.getElementById('historySection').style.display = 'block';
            
            // Add glitch effect
            predictionText.classList.add('glitch');
            setTimeout(() => predictionText.classList.remove('glitch'), 1000);
        }
        
        // Update history table
        function updateHistory(result, data) {
            const historyBody = document.getElementById('historyBody');
            const timestamp = new Date().toLocaleTimeString();
            
            aiPredictor.history.unshift({
                timestamp,
                model: result.modelType,
                data: data.slice(-8).join(','),
                prediction: result.prediction,
                confidence: result.confidence,
                features: Object.keys(result.features || {}).length,
                processingTime: result.processingTime
            });
            
            // Keep only last 20 predictions
            if (aiPredictor.history.length > 20) {
                aiPredictor.history = aiPredictor.history.slice(0, 20);
            }
            
            // Update table
            historyBody.innerHTML = '';
            aiPredictor.history.forEach(item => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${item.timestamp}</td>
                    <td>${item.model.toUpperCase()}</td>
                    <td>[${item.data}]</td>
                    <td class="${item.prediction.toLowerCase()}">${item.prediction}</td>
                    <td>${item.confidence}%</td>
                    <td>${item.features}</td>
                    <td><span class="status-indicator status-online"></span>Complete</td>
                `;
                historyBody.appendChild(row);
            });
        }
        
        // Update analytics
        function updateAnalytics(result) {
            aiPredictor.analytics.totalPredictions++;
            
            if (result.prediction === 'BIG') {
                aiPredictor.analytics.bigCount++;
            } else {
                aiPredictor.analytics.smallCount++;
            }
            
            // Update analytics display
            document.getElementById('bigPredictions').textContent = aiPredictor.analytics.bigCount;
            document.getElementById('smallPredictions').textContent = aiPredictor.analytics.smallCount;
            document.getElementById('streakCount').textContent = Math.floor(Math.random() * 5) + 1;
            document.getElementById('volatilityIndex').textContent = (Math.random() * 2 + 1).toFixed(1);
        }
        
        // Update charts
        function updateCharts(data, result) {
            updatePatternChart(data, result);
            updateTrendChart(data, result);
        }
        
        function updatePatternChart(data, result) {
            const chart = document.getElementById('patternChart');
            const recent = data.slice(-10);
            
            chart.innerHTML = '';
            recent.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.height = (value * 10 + 20) + 'px';
                bar.style.backgroundColor = value >= 5 ? '#ff3333' : '#3333ff';
                bar.title = `Position ${index + 1}: ${value}`;
                chart.appendChild(bar);
            });
            
            document.getElementById('patternAnalysis').innerHTML = `
                Pattern Analysis: ${recent.filter(x => x >= 5).length} BIG numbers, 
                ${recent.filter(x => x <= 4).length} SMALL numbers in last 10 entries.
            `;
        }
        
        function updateTrendChart(data, result) {
            const chart = document.getElementById('trendChart');
            const recent = data.slice(-10);
            
            chart.innerHTML = '';
            for (let i = 1; i < recent.length; i++) {
                const change = recent[i] - recent[i-1];
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.height = (Math.abs(change) * 15 + 10) + 'px';
                bar.style.backgroundColor = change > 0 ? '#00ff00' : change < 0 ? '#ff0000' : '#ffaa00';
                bar.title = `Change: ${change > 0 ? '+' : ''}${change}`;
                chart.appendChild(bar);
            }
            
            const trend = recent.length > 1 ? 
                (recent[recent.length - 1] > recent[0] ? 'Ascending' : 
                 recent[recent.length - 1] < recent[0] ? 'Descending' : 'Neutral') : 'Insufficient data';
            
            document.getElementById('trendAnalysis').innerHTML = `
                Trend Analysis: Overall trend is ${trend}. 
                Latest change: ${recent.length > 1 ? recent[recent.length - 1] - recent[recent.length - 2] : 'N/A'}
            `;
        }
        
        // Utility functions
        function generateRandomData() {
            const length = Math.floor(Math.random() * 15) + 10;
            const data = [];
            for (let i = 0; i < length; i++) {
                data.push(Math.floor(Math.random() * 10));
            }
            document.getElementById('dataInput').value = data.join(',');
            showNotification('Sample data generated!', 'info');
        }
        
        function clearData() {
            document.getElementById('dataInput').value = '';
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('chartSection').style.display = 'none';
            document.getElementById('trendSection').style.display = 'none';
            document.getElementById('analyticsSection').style.display = 'none';
            document.getElementById('historySection').style.display = 'none';
            
            aiPredictor.history = [];
            aiPredictor.analytics = {
                totalPredictions: 0,
                correctPredictions: 0,
                bigCount: 0,
                smallCount: 0,
                currentStreak: 0,
                maxStreak: 0,
                volatilityIndex: 0
            };
            
            showNotification('All data cleared!', 'info');
        }
        
        function realTimeMode() {
            if (!aiPredictor.realTimeMode) {
                aiPredictor.realTimeMode = true;
                aiPredictor.realTimeInterval = setInterval(() => {
                    const currentData = document.getElementById('dataInput').value;
                    if (currentData) {
                        // Simulate real-time data update
                        const newDigit = Math.floor(Math.random() * 10);
                        document.getElementById('dataInput').value = currentData + ',' + newDigit;
                        analyzeData();
                    }
                }, 5000);
                showNotification('Real-time mode activated!', 'success');
            } else {
                aiPredictor.realTimeMode = false;
                clearInterval(aiPredictor.realTimeInterval);
                showNotification('Real-time mode deactivated!', 'info');
            }
        }
        
        function showLoading(show) {
            const spinner = document.getElementById('loadingSpinner');
            const button = document.getElementById('analyzeBtn');
            
            if (show) {
                spinner.style.display = 'inline-block';
                button.innerHTML = '<span class="loading-spinner"></span> ANALYZING...';
                button.disabled = true;
            } else {
                spinner.style.display = 'none';
                button.innerHTML = 'AI PREDICT';
                button.disabled = false;
            }
        }
        
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            createMatrixEffect();
            
            // Add sample data after a delay
            setTimeout(() => {
                document.getElementById('dataInput').value = '3,7,1,9,4,6,2,8,0,5,3,8,1,7,4,9,2,6,3,8';
            }, 1500);
            
            showNotification('Naitik The Universe AI System Initialized!', 'success');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                analyzeData();
            } else if (e.key === 'Delete' && e.ctrlKey) {
                clearData();
            } else if (e.key === 'g' && e.ctrlKey) {
                e.preventDefault();
                generateRandomData();
            }
        });
    </script>
</body>
</html>
